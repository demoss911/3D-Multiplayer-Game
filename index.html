<!DOCTYPE html>
<html>
<head>
    <title>3D Multiplayer Prototype</title>
    <style> 
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: sans-serif; } 
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            pointer-events: none; /* Let clicks pass through to the game */
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
</head>
<body>

<div id="ui">
    <div style="font-size: 12px; opacity: 0.8;">CONNECTION STATUS: <span id="status" style="color: #ff4444;">Connecting...</span></div>
    <div style="font-size: 20px; font-weight: bold; margin-top: 5px;">Players Online: <span id="player-count">0</span></div>
</div>

<script>
    // --- CONNECT TO YOUR LIVE BACKEND ---
    const SERVER_URL = "https://multiplayer-backend-uz4n.onrender.com"; 
    const socket = io(SERVER_URL);
    
    const statusEl = document.getElementById('status');
    const countEl = document.getElementById('player-count');

    socket.on('connect', () => {
        statusEl.innerText = "ONLINE";
        statusEl.style.color = "#44ff44";
    });

    socket.on('disconnect', () => {
        statusEl.innerText = "OFFLINE";
        statusEl.style.color = "#ff4444";
    });

    // --- 1. SETUP THE 3D WORLD ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const floorGeo = new THREE.PlaneGeometry(50, 50);
    const floorMat = new THREE.MeshBasicMaterial({ color: 0x555555, side: THREE.DoubleSide });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = Math.PI / 2;
    scene.add(floor);

    camera.position.set(0, 8, 15);
    camera.lookAt(0, 0, 0);

    // --- 2. PLAYER MANAGEMENT ---
    const otherPlayers = {}; 
    let myMesh; 

    function updatePlayerCount() {
        // Total players = opponents + you
        const total = Object.keys(otherPlayers).length + (myMesh ? 1 : 0);
        countEl.innerText = total;
    }

    function addPlayerToScene(id, playerData, isMe) {
        const geometry = new THREE.BoxGeometry(1, 2, 1);
        const material = new THREE.MeshBasicMaterial({ color: playerData.color });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(playerData.x, playerData.y, playerData.z);
        scene.add(mesh);
        
        if (isMe) myMesh = mesh;
        else otherPlayers[id] = mesh;
        
        updatePlayerCount();
    }

    // --- 3. NETWORK LISTENERS ---
    socket.on('currentPlayers', (players) => {
        Object.keys(players).forEach((id) => {
            if (id === socket.id) addPlayerToScene(id, players[id], true);
            else addPlayerToScene(id, players[id], false);
        });
    });

    socket.on('newPlayer', (data) => addPlayerToScene(data.id, data.player, false));

    socket.on('playerMoved', (data) => {
        if (otherPlayers[data.id]) {
            otherPlayers[data.id].position.x = data.x;
            otherPlayers[data.id].position.z = data.z;
        }
    });

    socket.on('playerDisconnected', (id) => {
        if (otherPlayers[id]) {
            scene.remove(otherPlayers[id]);
            delete otherPlayers[id];
            updatePlayerCount();
        }
    });

    // --- 4. MOVEMENT & RENDERING ---
    const speed = 0.2;
    const keys = { w: false, a: false, s: false, d: false };

    window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

    function animate() {
        requestAnimationFrame(animate);

        if (myMesh) {
            let moved = false;
            if (keys['w']) { myMesh.position.z -= speed; moved = true; }
            if (keys['s']) { myMesh.position.z += speed; moved = true; }
            if (keys['a']) { myMesh.position.x -= speed; moved = true; }
            if (keys['d']) { myMesh.position.x += speed; moved = true; }

            if (moved) socket.emit('playerMovement', { x: myMesh.position.x, z: myMesh.position.z });
        }

        renderer.render(scene, camera);
    }
    animate(); 

    // Handle window resizing
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>